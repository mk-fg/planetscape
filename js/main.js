// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var conntrace, fs, k, opts, path, proj, svg, u, util, v, yaml,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  u = require('./js/utils');

  conntrace = require('./js/conntrace');

  path = require('path');

  fs = require('fs');

  util = require('util');

  yaml = require('js-yaml');

  opts = {
    w: window.innerWidth * 0.9,
    h: window.innerHeight * 0.9,
    world: require('./data/world-110m.json'),
    projections: {
      'Aitoff': function() {
        return d3.geo.aitoff();
      },
      'Albers': function() {
        return d3.geo.albers().scale(145).parallels([20, 50]);
      },
      'August': function() {
        return d3.geo.august().scale(60);
      },
      'Baker': function() {
        return d3.geo.baker().scale(100);
      },
      'Boggs': function() {
        return d3.geo.boggs();
      },
      'Bonne': function() {
        return d3.geo.bonne().scale(100);
      },
      'Bromley': function() {
        return d3.geo.bromley();
      },
      'Collignon': function() {
        return d3.geo.collignon().scale(93);
      },
      'Craster Parabolic': function() {
        return d3.geo.craster();
      },
      'Eckert I': function() {
        return d3.geo.eckert1().scale(165);
      },
      'Eckert II': function() {
        return d3.geo.eckert2().scale(165);
      },
      'Eckert III': function() {
        return d3.geo.eckert3().scale(180);
      },
      'Eckert IV': function() {
        return d3.geo.eckert4().scale(180);
      },
      'Eckert V': function() {
        return d3.geo.eckert5().scale(170);
      },
      'Eckert VI': function() {
        return d3.geo.eckert6().scale(170);
      },
      'Eisenlohr': function() {
        return d3.geo.eisenlohr().scale(60);
      },
      'Equirectangular (Plate Carrée)': function() {
        return d3.geo.equirectangular();
      },
      'Goode Homolosine': function() {
        return d3.geo.homolosine();
      },
      'Hammer': function() {
        return d3.geo.hammer().scale(165);
      },
      'Hill': function() {
        return d3.geo.hill();
      },
      'Kavrayskiy VII': function() {
        return d3.geo.kavrayskiy7();
      },
      'Lagrange': function() {
        return d3.geo.lagrange().scale(120);
      },
      'Lambert cylindrical equal-area': function() {
        return d3.geo.cylindricalEqualArea();
      },
      'Larrivée': function() {
        return d3.geo.larrivee().scale(95);
      },
      'Laskowski': function() {
        return d3.geo.laskowski().scale(120);
      },
      'Loximuthal': function() {
        return d3.geo.loximuthal();
      },
      'McBryde–Thomas Flat-Polar Parabolic': function() {
        return d3.geo.mtFlatPolarParabolic();
      },
      'McBryde–Thomas Flat-Polar Quartic': function() {
        return d3.geo.mtFlatPolarQuartic();
      },
      'McBryde–Thomas Flat-Polar Sinusoidal': function() {
        return d3.geo.mtFlatPolarSinusoidal();
      },
      'Miller': function() {
        return d3.geo.miller().scale(100);
      },
      'Mollweide': function() {
        return d3.geo.mollweide().scale(165);
      },
      'Natural Earth': function() {
        return d3.geo.naturalEarth();
      },
      'Nell–Hammer': function() {
        return d3.geo.nellHammer();
      },
      'Polyconic': function() {
        return d3.geo.polyconic().scale(100);
      },
      'Robinson': function() {
        return d3.geo.robinson();
      },
      'Sinu-Mollweide': function() {
        return d3.geo.sinuMollweide();
      },
      'Sinusoidal': function() {
        return d3.geo.sinusoidal();
      },
      'Wagner IV': function() {
        return d3.geo.wagner4();
      },
      'Wagner VI': function() {
        return d3.geo.wagner6();
      },
      'Wagner VII': function() {
        return d3.geo.wagner7();
      },
      'Winkel Tripel': function() {
        return d3.geo.winkel3();
      },
      'van der Grinten': function() {
        return d3.geo.vanDerGrinten().scale(75);
      },
      'van der Grinten IV': function() {
        return d3.geo.vanDerGrinten4().scale(120);
      }
    },
    config_path_base: './data/config.yaml',
    config_path: [],
    config: null
  };

  (function() {
    var conf, conf_merge, err, k, p0, path_conf, path_conf_bases, path_conf_order, path_home, scale_factor, _fn, _ref, _ref1, _ref2, _results;
    scale_factor = Math.min(opts.w / 960, opts.h / 500);
    _ref = opts.projections;
    _fn = function(p0) {
      return opts.projections[k] = function() {
        var p, v;
        p = p0().rotate([0, 0, 0]).center([0, 0]);
        return p.scale(p.scale() * scale_factor).translate((function() {
          var _i, _len, _ref1, _results;
          _ref1 = p.translate();
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            v = _ref1[_i];
            _results.push(v * scale_factor);
          }
          return _results;
        })());
      };
    };
    for (k in _ref) {
      p0 = _ref[k];
      _fn(p0);
    }
    path_home = process.env[(process.platform === 'win32' ? 'USERPROFILE' : 'HOME')];
    conf_merge = function(conf, ext) {
      var v;
      if (!conf) {
        conf = ext;
      } else {
        for (k in ext) {
          if (!__hasProp.call(ext, k)) continue;
          v = ext[k];
          if (k in conf) {
            if (Array.isArray(conf[k]) && Array.isArray(v)) {
              v = d3.merge([conf[k], v]);
            } else if (typeof conf[k] === 'object' && typeof v === 'object') {
              v = conf_merge(conf[k], v);
            }
          }
          conf[k] = v;
        }
      }
      return conf;
    };
    _ref1 = [[opts.config_path_base], d3.set()], path_conf_order = _ref1[0], path_conf_bases = _ref1[1];
    _results = [];
    while (path_conf_order.length) {
      _ref2 = [path_conf_order[0], path_conf_order.slice(1)], path_conf = _ref2[0], path_conf_order = _ref2[1];
      if (path_conf.match(/^~\//)) {
        u.assert(path_home, 'Unable to get user home path from env');
        path_conf = path.join(path_home, path_conf.substr(2));
      }
      path_conf = path.resolve(path_conf);
      try {
        path_conf = fs.realpathSync(path_conf);
      } catch (_error) {
        continue;
      }
      if (__indexOf.call(opts.config_path, path_conf) >= 0) {
        continue;
      }
      try {
        conf = yaml.safeLoad(fs.readFileSync(path_conf, {
          encoding: 'utf-8'
        }), {
          filename: path_conf,
          strict: true,
          schema: yaml.CORE_SCHEMA
        });
      } catch (_error) {
        err = _error;
        util.error("Failed to process configuration file: " + path_conf + "\n  " + err);
        process.exit(1);
      }
      if (conf.base && !path_conf_bases.has(conf.base)) {
        path_conf_order = d3.merge([[conf.base, path_conf], path_conf_order]);
        path_conf_bases.add(conf.base);
        continue;
      }
      opts.config = conf_merge(opts.config, conf);
      opts.config_path.push(path_conf);
      if (process.env['PSC_CONF']) {
        opts.config.extension = process.env['PSC_CONF'];
        delete process.env['PSC_CONF'];
      }
      if (opts.config.extension) {
        path_conf_order.unshift(opts.config.extension);
      }
      delete opts.config.base;
      _results.push(delete opts.config.extension);
    }
    return _results;
  })();

  proj = {
    name: opts.config.projection.name,
    func: null,
    path: null,
    list: (function() {
      var _ref, _results;
      _ref = opts.projections;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(k);
      }
      return _results;
    })(),
    graticule: d3.geo.graticule(),
    traces: null,
    markers: null
  };

  proj.func = opts.projections[proj.name]().translate([opts.w / 2, opts.h / 2]);

  proj.path = d3.geo.path().projection(proj.func);

  svg = d3.select('svg').attr('width', opts.w).attr('height', opts.h).attr('class', 'centered').style({
    'margin-left': '-' + (opts.w / 2) + 'px',
    'margin-top': '-' + (opts.h / 2) + 'px'
  });

  svg.append('defs').append('path').datum({
    type: 'Sphere'
  }).attr('id', 'sphere').attr('d', proj.path);

  svg.append('use').attr('class', 'stroke').attr('xlink:href', '#sphere');

  svg.append('use').attr('class', 'fill').attr('xlink:href', '#sphere');

  svg.append('path').datum(proj.graticule).attr('class', 'graticule').attr('d', proj.path);

  svg.insert('path', '.graticule').datum(topojson.feature(opts.world, opts.world.objects.land)).attr('class', 'land').attr('d', proj.path);

  proj.traces = svg.append('g').attr('id', 'traces');

  proj.markers = svg.append('g').attr('id', 'markers');

  (function() {
    var menu_opts, projectionTween, update;
    projectionTween = function(projection0, projection1) {
      return function(d) {
        var project, t;
        project = function(λ, φ) {
          var p0, p1, _ref;
          λ *= 180 / Math.PI;
          φ *= 180 / Math.PI;
          _ref = [projection0([λ, φ]), projection1([λ, φ])], p0 = _ref[0], p1 = _ref[1];
          return [(1 - t) * p0[0] + t * p1[0], (1 - t) * -p0[1] + t * -p1[1]];
        };
        t = 0;
        proj.func = d3.geo.projection(project).scale(1).translate([opts.w / 2, opts.h / 2]);
        proj.path = d3.geo.path().projection(proj.func);
        return function(_) {
          t = _;
          return proj.path(d);
        };
      };
    };
    update = function() {
      var projection0, _ref;
      k = proj.list[this.selectedIndex];
      _ref = [proj.func, opts.projections[k]()], projection0 = _ref[0], proj.func = _ref[1];
      proj.name = k;
      return svg.selectAll('path').transition().duration(750).attrTween('d', projectionTween(projection0, proj.func));
    };
    menu_opts = d3.select('#projection-menu').style('display', 'block').on('change', update).selectAll('option').data((function() {
      var _ref, _results;
      _ref = opts.projections;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push({
          name: k,
          projection: v()
        });
      }
      return _results;
    })());
    menu_opts.enter().append('option').text(function(d) {
      return d.name;
    });
    return menu_opts.attr('selected', function(d) {
      if (d.name === proj.name) {
        return true;
      } else {
        return null;
      }
    });
  })();

  (function() {
    var ct, draw_traces, source, trace_path, tracer;
    tracer = conntrace.Tracer.in_domain();
    ct = conntrace.ConntrackSS.in_domain();
    if (ct.polling) {
      ct.on('conn_list', function(conn_list) {
        var conn;
        return tracer.conn_list((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = conn_list.length; _i < _len; _i++) {
            conn = conn_list[_i];
            _results.push(conn.remote.addr);
          }
          return _results;
        })());
      });
    } else {
      ct.on('conn_add', function(conn) {
        return tracer.conn_add(conn.remote.addr);
      }).on('conn_del', function(conn) {
        return tracer.conn_del(conn.remote.addr);
      });
    }
    trace_path = d3.geo.path().projection(proj.func);
    source = opts.config.projection.source;
    draw_traces = function(traces) {
      var data, ip, marker_traces, markers, trace;
      data = (function() {
        var _results;
        _results = [];
        for (ip in traces) {
          if (!__hasProp.call(traces, ip)) continue;
          trace = traces[ip];
          if (trace.filter(function(d) {
            return d.geo;
          }).length !== 0) {
            _results.push({
              ip: ip,
              trace: trace
            });
          }
        }
        return _results;
      })();
      traces = proj.traces.selectAll('path.trace').data(data, function(d) {
        return d.ip;
      });
      traces.enter().append('path').datum(function(d) {
        return {
          type: 'MultiLineString',
          coordinates: (function() {
            var line, node, p0, p1, _i, _len, _ref, _ref1, _results;
            p0 = source.slice(0).reverse();
            _ref = d.trace;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              u.assert(node.geo, [node, d.trace]);
              p1 = node.geo.slice(0).reverse();
              _ref1 = [p1, [p0, p1]], p0 = _ref1[0], line = _ref1[1];
              _results.push(line);
            }
            return _results;
          })()
        };
      }).attr('class', 'trace').attr('d', trace_path);
      traces.exit().remove();
      marker_traces = proj.markers.selectAll('g').data(data, function(d) {
        return d.ip;
      });
      marker_traces.enter().append('g');
      marker_traces.exit().remove();
      markers = marker_traces.selectAll('circle').data(function(d) {
        return d.trace;
      });
      markers.enter().append('circle').datum(function(d) {
        return proj.func(d.geo.slice(0).reverse());
      }).attr('class', 'point').attr('cx', function(d) {
        return d[0];
      }).attr('cy', function(d) {
        return d[1];
      }).attr('r', 2);
      return markers.exit().remove();
    };
    if (!opts.config.debug.traces.load_from) {
      ct.start(opts.config.updates.conntrack_poll);
    } else {
      (function() {
        var json;
        json = fs.readFileSync(opts.config.debug.traces.load_from);
        return tracer.conn.active = JSON.parse(json);
      })();
    }
    return u.add_task_now(opts.config.updates.redraw, function() {
      var traces;
      traces = tracer.conn.active;
      if (opts.config.debug.traces.dump) {
        util.debug(JSON.stringify(traces));
      }
      return draw_traces(traces);
    });
  })();

}).call(this);
