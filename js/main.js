// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Cache, ConntrackSS, Mtr, Tracer, assert, child_process, domain, dump, events, geoip, graticule, k, o, opts, p0, path, projection, projection_name, projections_idx, scale_factor, stream, svg, throw_err, util, v, _fn, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = require('util');

  throw_err = function(msg) {
    throw new Error(msg || 'Unspecified Error');
  };

  assert = function(condition, msg) {
    if (!condition) {
      if (typeof msg !== 'string') {
        dump(msg, 'Error Data Context');
      }
      return throw_err(msg || 'Assertion failed');
    }
  };

  dump = function(data, label, opts) {
    if (label == null) {
      label = 'unlabeled object';
    }
    if (opts == null) {
      opts = {};
    }
    if (opts.colors == null) {
      opts.colors = true;
    }
    if (opts.depth == null) {
      opts.depth = 4;
    }
    return util.debug(("" + label + "\n") + util.inspect(data, opts));
  };

  domain = require('domain');

  events = require('events');

  child_process = require('child_process');

  stream = require('stream');

  Mtr = require('mtr').Mtr;

  geoip = require('geoip-lite');

  opts = {
    w: window.innerWidth * 0.9,
    h: window.innerHeight * 0.9,
    world: require('./data/world-110m.json'),
    projections: {
      'Aitoff': function() {
        return d3.geo.aitoff();
      },
      'Albers': function() {
        return d3.geo.albers().scale(145).parallels([20, 50]);
      },
      'August': function() {
        return d3.geo.august().scale(60);
      },
      'Baker': function() {
        return d3.geo.baker().scale(100);
      },
      'Boggs': function() {
        return d3.geo.boggs();
      },
      'Bonne': function() {
        return d3.geo.bonne().scale(100);
      },
      'Bromley': function() {
        return d3.geo.bromley();
      },
      'Collignon': function() {
        return d3.geo.collignon().scale(93);
      },
      'Craster Parabolic': function() {
        return d3.geo.craster();
      },
      'Eckert I': function() {
        return d3.geo.eckert1().scale(165);
      },
      'Eckert II': function() {
        return d3.geo.eckert2().scale(165);
      },
      'Eckert III': function() {
        return d3.geo.eckert3().scale(180);
      },
      'Eckert IV': function() {
        return d3.geo.eckert4().scale(180);
      },
      'Eckert V': function() {
        return d3.geo.eckert5().scale(170);
      },
      'Eckert VI': function() {
        return d3.geo.eckert6().scale(170);
      },
      'Eisenlohr': function() {
        return d3.geo.eisenlohr().scale(60);
      },
      'Equirectangular (Plate Carrée)': function() {
        return d3.geo.equirectangular();
      },
      'Goode Homolosine': function() {
        return d3.geo.homolosine();
      },
      'Hammer': function() {
        return d3.geo.hammer().scale(165);
      },
      'Hill': function() {
        return d3.geo.hill();
      },
      'Kavrayskiy VII': function() {
        return d3.geo.kavrayskiy7();
      },
      'Lagrange': function() {
        return d3.geo.lagrange().scale(120);
      },
      'Lambert cylindrical equal-area': function() {
        return d3.geo.cylindricalEqualArea();
      },
      'Larrivée': function() {
        return d3.geo.larrivee().scale(95);
      },
      'Laskowski': function() {
        return d3.geo.laskowski().scale(120);
      },
      'Loximuthal': function() {
        return d3.geo.loximuthal();
      },
      'McBryde–Thomas Flat-Polar Parabolic': function() {
        return d3.geo.mtFlatPolarParabolic();
      },
      'McBryde–Thomas Flat-Polar Quartic': function() {
        return d3.geo.mtFlatPolarQuartic();
      },
      'McBryde–Thomas Flat-Polar Sinusoidal': function() {
        return d3.geo.mtFlatPolarSinusoidal();
      },
      'Miller': function() {
        return d3.geo.miller().scale(100);
      },
      'Mollweide': function() {
        return d3.geo.mollweide().scale(165);
      },
      'Natural Earth': function() {
        return d3.geo.naturalEarth();
      },
      'Nell–Hammer': function() {
        return d3.geo.nellHammer();
      },
      'Polyconic': function() {
        return d3.geo.polyconic().scale(100);
      },
      'Robinson': function() {
        return d3.geo.robinson();
      },
      'Sinu-Mollweide': function() {
        return d3.geo.sinuMollweide();
      },
      'Sinusoidal': function() {
        return d3.geo.sinusoidal();
      },
      'Wagner IV': function() {
        return d3.geo.wagner4();
      },
      'Wagner VI': function() {
        return d3.geo.wagner6();
      },
      'Wagner VII': function() {
        return d3.geo.wagner7();
      },
      'Winkel Tripel': function() {
        return d3.geo.winkel3();
      },
      'van der Grinten': function() {
        return d3.geo.vanDerGrinten().scale(75);
      },
      'van der Grinten IV': function() {
        return d3.geo.vanDerGrinten4().scale(120);
      }
    },
    defaults: {
      source: [56.833333, 60.583333],
      projection: 'Equirectangular (Plate Carrée)',
      conntrack_poll_interval: 3
    }
  };

  scale_factor = Math.min(opts.w / 960, opts.h / 500);

  _ref = opts.projections;
  _fn = function(p0) {
    return opts.projections[k] = function() {
      var p, v;
      p = p0().rotate([0, 0, 0]).center([0, 0]);
      return p.scale(p.scale() * scale_factor).translate((function() {
        var _i, _len, _ref1, _results;
        _ref1 = p.translate();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          v = _ref1[_i];
          _results.push(v * scale_factor);
        }
        return _results;
      })());
    };
  };
  for (k in _ref) {
    p0 = _ref[k];
    _fn(p0);
  }

  projections_idx = (function() {
    var _ref1, _results;
    _ref1 = opts.projections;
    _results = [];
    for (k in _ref1) {
      v = _ref1[k];
      _results.push(k);
    }
    return _results;
  })();

  projection_name = opts.defaults.projection;

  projection = opts.projections[projection_name]().translate([opts.w / 2, opts.h / 2]);

  path = d3.geo.path().projection(projection);

  graticule = d3.geo.graticule();

  svg = d3.select('svg').attr('width', opts.w).attr('height', opts.h).attr('class', 'centered').style({
    'margin-left': '-' + (opts.w / 2) + 'px',
    'margin-top': '-' + (opts.h / 2) + 'px'
  });

  svg.append('defs').append('path').datum({
    type: 'Sphere'
  }).attr('id', 'sphere').attr('d', path);

  svg.append('use').attr('class', 'stroke').attr('xlink:href', '#sphere');

  svg.append('use').attr('class', 'fill').attr('xlink:href', '#sphere');

  svg.append('path').datum(graticule).attr('class', 'graticule').attr('d', path);

  svg.insert('path', '.graticule').datum(topojson.feature(opts.world, opts.world.objects.land)).attr('class', 'land').attr('d', path);

  (function() {
    var menu_opts, projectionTween, update;
    projectionTween = function(projection0, projection1) {
      return function(d) {
        var project, t;
        project = function(λ, φ) {
          var p1, _ref1;
          λ *= 180 / Math.PI;
          φ *= 180 / Math.PI;
          _ref1 = [projection0([λ, φ]), projection1([λ, φ])], p0 = _ref1[0], p1 = _ref1[1];
          return [(1 - t) * p0[0] + t * p1[0], (1 - t) * -p0[1] + t * -p1[1]];
        };
        t = 0;
        projection = d3.geo.projection(project).scale(1).translate([opts.w / 2, opts.h / 2]);
        path = d3.geo.path().projection(projection);
        return function(_) {
          t = _;
          return path(d);
        };
      };
    };
    update = function() {
      var projection0, _ref1;
      k = projections_idx[this.selectedIndex];
      _ref1 = [projection, opts.projections[k]()], projection0 = _ref1[0], projection = _ref1[1];
      projection_name = k;
      return svg.selectAll('path').transition().duration(750).attrTween('d', projectionTween(projection0, projection));
    };
    menu_opts = d3.select('#projection-menu').style('display', 'block').on('change', update).selectAll('option').data((function() {
      var _ref1, _results;
      _ref1 = opts.projections;
      _results = [];
      for (k in _ref1) {
        v = _ref1[k];
        _results.push({
          name: k,
          projection: v()
        });
      }
      return _results;
    })());
    menu_opts.enter().append('option').text(function(d) {
      return d.name;
    });
    return menu_opts.attr('selected', function(d) {
      if (d.name === projection_name) {
        return true;
      } else {
        return null;
      }
    });
  })();

  Cache = (function(_super) {
    __extends(Cache, _super);

    function Cache(data, lwm, hwm_k) {
      var ts, _ref1;
      this.lwm = lwm != null ? lwm : 300;
      if (hwm_k == null) {
        hwm_k = 1.5;
      }
      Cache.__super__.constructor.call(this);
      _ref1 = [d3.map(), this.lwm * hwm_k], this.data = _ref1[0], this.hwm = _ref1[1];
      if (data) {
        ts = (new Date()).getTime();
        for (k in data) {
          if (!__hasProp.call(data, k)) continue;
          v = data[k];
          this.set(k, v, ts);
        }
      }
      this.on('set', this.clean);
    }

    Cache.prototype.has = function(k) {
      return this.data.has(k);
    };

    Cache.prototype.get = function(k, ts) {
      v = this.data.get(k);
      if (v == null) {
        return v;
      }
      if (ts == null) {
        ts = (new Date()).getTime();
      }
      v.ts = ts;
      this.emit('get', k, v.v, ts);
      return v.v;
    };

    Cache.prototype.set = function(k, v, ts) {
      if (ts == null) {
        ts = (new Date()).getTime();
      }
      this.data.set({
        ts: ts,
        v: v
      });
      return this.emit('set', k, v, ts);
    };

    Cache.prototype.clean = function() {
      var e, _i, _len, _ref1, _results;
      if (this.data.size() <= this.hwm) {
        return;
      }
      _ref1 = this.data.entries().sort(function(a, b) {
        return a.ts - b.ts;
      }).slice(0, +this.lwm + 1 || 9e9);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        e = _ref1[_i];
        _results.push(this.data.remove(e.key));
      }
      return _results;
    };

    return Cache;

  })(events.EventEmitter);

  Tracer = (function(_super) {
    __extends(Tracer, _super);

    Tracer.prototype.mtr_cycles = 1;

    Tracer.prototype.geotrace = function(ip) {
      var hop_label_format, hops, label_buff, last_hop, link_length, mtr, self, _ref1, _ref2;
      mtr = new Mtr(ip, {
        reportCycles: this.mtr_cycles
      });
      _ref1 = [this, []], self = _ref1[0], hops = _ref1[1];
      _ref2 = [0, null, []], link_length = _ref2[0], last_hop = _ref2[1], label_buff = _ref2[2];
      hop_label_format = function(hop) {
        var label;
        label = hop.ip;
        if (label_buff.length) {
          label_buff.push(label);
          label = label_buff.join(' -> ');
          label_buff = [];
        }
        return label;
      };
      return mtr.on('hop', function(hop) {
        var geo, label, loc, _ref3;
        link_length += 1;
        last_hop = hop;
        if (hop.number === 1 || !hop.ip) {
          return;
        }
        geo = geoip.lookup(hop.ip);
        if (!geo) {
          label_buff.push(label_addr);
          return;
        }
        label = hop_label_format(hop);
        loc = geo.city ? "" + geo.city + ", " + geo.country : "" + geo.country;
        hops.push({
          label: "" + label + " (" + loc + ")",
          geo: geo.ll,
          link: link_length
        });
        return _ref3 = [0, null], link_length = _ref3[0], last_hop = _ref3[1], _ref3;
      }).on('end', function() {
        var label;
        if (last_hop) {
          label = hop_label_format(last_hop);
          hops.push({
            label: "" + label,
            geo: null,
            link: link_length
          });
        }
        return self.emit('trace', ip, hops);
      }).on('error', function(err) {
        return console.log('traceroute error (ip: #{ip}): #{err.message}');
      }).traceroute();
    };

    Tracer.prototype.conn_add = function(ip) {
      return this.emit('conn_add', ip);
    };

    Tracer.prototype.conn_del = function(ip) {
      return this.emit('conn_del', ip);
    };

    Tracer.prototype.conn_list = function(ip_list) {
      return this.emit('conn_list', ip_list);
    };

    function Tracer() {
      Tracer.__super__.constructor.call(this);
      this.conn = {
        active: {},
        pending: {},
        cache: new Cache()
      };
      this.on('trace', function(ip, hops) {
        if (!this.conn.pending[ip]) {
          return;
        }
        this.conn.active[ip] = hops;
        this.conn.cache.set(ip, hops);
        return delete this.conn.pending[ip];
      }).on('conn_add', function(ip) {
        var hops;
        if (this.conn.active[ip]) {
          return;
        }
        hops = this.conn.cache.get(ip);
        if (hops) {
          return this.emit('trace', ip, hops);
        } else {
          this.conn.pending[ip] = true;
          return this.geotrace(ip);
        }
      }).on('conn_del', function(ip) {
        if (!this.conn.active[ip]) {
          return;
        }
        delete this.conn.active[ip];
        return delete this.conn.pending[ip];
      }).on('conn_list', function(ip_list) {
        var active, hops, ip, _i, _len, _ref1, _results;
        active = {};
        _ref1 = this.conn.active;
        for (ip in _ref1) {
          if (!__hasProp.call(_ref1, ip)) continue;
          hops = _ref1[ip];
          active[k] = v;
        }
        for (_i = 0, _len = ip_list.length; _i < _len; _i++) {
          ip = ip_list[_i];
          if (active[ip]) {
            delete active[ip];
            continue;
          }
          this.conn_add(ip);
        }
        _results = [];
        for (ip in active) {
          if (!__hasProp.call(active, ip)) continue;
          hops = active[ip];
          _results.push(this.conn_del(ip));
        }
        return _results;
      });
    }

    Tracer.in_domain = function(d) {
      if (!d) {
        d = domain.create();
      }
      return d.run(function() {
        return new Tracer();
      });
    };

    return Tracer;

  })(events.EventEmitter);

  ConntrackSS = (function(_super) {
    __extends(ConntrackSS, _super);

    function ConntrackSS() {
      return ConntrackSS.__super__.constructor.apply(this, arguments);
    }

    ConntrackSS.prototype.polling = true;

    ConntrackSS.prototype.poll = function() {
      var self, ss, ss_buff, ss_err, ss_header, ss_out, _ref1;
      self = this;
      ss = child_process.spawn('ss', ['-np', '-A', 'inet', 'state', 'established'], {
        stdio: ['ignore', 'pipe', process.stderr]
      });
      _ref1 = ['', '', true, []], ss_out = _ref1[0], ss_err = _ref1[1], ss_header = _ref1[2], ss_buff = _ref1[3];
      ss.stdout.on('end', function() {
        return self.emit('conn_list', ss_buff);
      }).on('data', function(d) {
        var conn, e, line, lines, m, p, props, proto, q_recv, q_send, re, s, s_local, s_remote, _i, _len, _ref2, _ref3, _ref4, _ref5, _results;
        ss_out += d;
        lines = ss_out.split('\n');
        if (lines.length < 2) {
          return;
        }
        _ref2 = [lines[lines.length - 1], lines.slice(0, -1)], ss_out = _ref2[0], lines = _ref2[1];
        if (ss_header) {
          lines = lines.slice(1);
        }
        _results = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          line = line.split(/\s+/);
          assert((_ref3 = line.length) === 5 || _ref3 === 6);
          if (line.length === 6) {
            _ref4 = [line[line.length - 1], line.slice(0, -1)], props = _ref4[0], line = _ref4[1];
          }
          proto = line[0], q_recv = line[1], q_send = line[2], s_local = line[3], s_remote = line[4];
          _ref5 = (function() {
            var _j, _len1, _ref5, _results1;
            _ref5 = [s_local, s_remote];
            _results1 = [];
            for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
              s = _ref5[_j];
              _results1.push(s.match(/^(.+):(\d+)$/).slice(1, 3));
            }
            return _results1;
          })(), s_local = _ref5[0], s_remote = _ref5[1];
          if (props) {
            try {
              props = {
                users: ((function() {
                  var _results1;
                  p = props.match(/^users:\((.*)\)$/);
                  assert(p, "Can't match 'users:...' from: " + props);
                  re = /\("((?:[^\\"]|\\.)*)",(\d+),(\d+)\)(?:,|$)/g;
                  _results1 = [];
                  while (m = re.exec(p[1])) {
                    _results1.push({
                      cmd: m[1],
                      pid: parseInt(m[2]),
                      fd: parseInt(m[3])
                    });
                  }
                  return _results1;
                })())
              };
            } catch (_error) {
              e = _error;
              throw_err("Failed to parse prop-string `" + props + "': " + e);
            }
          }
          conn = {
            proto: proto,
            queues: {
              recv: parseInt(q_recv),
              send: parseInt(q_send)
            },
            local: {
              addr: s_local[0],
              port: parseInt(s_local[1])
            },
            remote: {
              addr: s_remote[0],
              port: parseInt(s_remote[1])
            },
            props: props
          };
          _results.push(ss_buff.push(conn));
        }
        return _results;
      }).setEncoding('utf8');
      return ss.on('exit', function(code, sig) {
        if ((code == null) || code !== 0 || sig) {
          return throw_err("ss - exit with error: " + code + ", " + sig);
        }
      }).on('error', function(err) {
        return throw_err("ss - failed to run: " + err);
      });
    };

    ConntrackSS.prototype.start = function(poll_interval) {
      assert(!this.timer, this.timer);
      return this.timer = (function(s) {
        return setInterval((function() {
          return s.poll();
        }), poll_interval * 1000);
      })(this);
    };

    ConntrackSS.prototype.stop = function() {
      return this.timer = this.timer && clearInterval(this.timer) && null;
    };

    ConntrackSS.in_domain = function(d) {
      if (!d) {
        d = domain.create();
      }
      return d.run(function() {
        return new ConntrackSS();
      });
    };

    return ConntrackSS;

  })(events.EventEmitter);

  o = projection(opts.defaults.source.reverse());

  svg.append('svg:circle').attr('class', 'point').attr('cx', o[0]).attr('cy', o[1]).attr('r', 4).attr('title', 'source');

  (function() {
    var ct, tracer;
    tracer = Tracer.in_domain();
    ct = ConntrackSS.in_domain();
    if (ct.polling) {
      ct.on('conn_list', function(conn_list) {
        var conn;
        return tracer.conn_list((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = conn_list.length; _i < _len; _i++) {
            conn = conn_list[_i];
            _results.push(conn.remote.addr);
          }
          return _results;
        })());
      });
    } else {
      ct.on('conn_add', function(conn) {
        return tracer.conn_add(conn.remote.addr);
      }).on('conn_del', function(conn) {
        return tracer.conn_del(conn.remote.addr);
      });
    }
    return ct.start(opts.defaults.conntrack_poll_interval);
  })();

}).call(this);
