// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Cache, ConntrackSS, Mtr, Tracer, assert, child_process, domain, dump, events, geoip, k, opts, proj, stream, svg, throw_err, util, v,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = require('util');

  throw_err = function(msg) {
    throw new Error(msg || 'Unspecified Error');
  };

  assert = function(condition, msg) {
    if (!condition) {
      if ((msg != null) && typeof msg !== 'string') {
        dump(msg, 'Error Data Context');
      }
      return throw_err(msg || 'Assertion failed');
    }
  };

  dump = function(data, label, opts) {
    if (label == null) {
      label = 'unlabeled object';
    }
    if (opts == null) {
      opts = {};
    }
    if (opts.colors == null) {
      opts.colors = true;
    }
    if (opts.depth == null) {
      opts.depth = 4;
    }
    return util.debug(("" + label + "\n") + util.inspect(data, opts));
  };

  domain = require('domain');

  events = require('events');

  child_process = require('child_process');

  stream = require('stream');

  Mtr = require('mtr').Mtr;

  geoip = require('geoip-lite');

  opts = {
    w: window.innerWidth * 0.9,
    h: window.innerHeight * 0.9,
    world: require('./data/world-110m.json'),
    projections: {
      'Aitoff': function() {
        return d3.geo.aitoff();
      },
      'Albers': function() {
        return d3.geo.albers().scale(145).parallels([20, 50]);
      },
      'August': function() {
        return d3.geo.august().scale(60);
      },
      'Baker': function() {
        return d3.geo.baker().scale(100);
      },
      'Boggs': function() {
        return d3.geo.boggs();
      },
      'Bonne': function() {
        return d3.geo.bonne().scale(100);
      },
      'Bromley': function() {
        return d3.geo.bromley();
      },
      'Collignon': function() {
        return d3.geo.collignon().scale(93);
      },
      'Craster Parabolic': function() {
        return d3.geo.craster();
      },
      'Eckert I': function() {
        return d3.geo.eckert1().scale(165);
      },
      'Eckert II': function() {
        return d3.geo.eckert2().scale(165);
      },
      'Eckert III': function() {
        return d3.geo.eckert3().scale(180);
      },
      'Eckert IV': function() {
        return d3.geo.eckert4().scale(180);
      },
      'Eckert V': function() {
        return d3.geo.eckert5().scale(170);
      },
      'Eckert VI': function() {
        return d3.geo.eckert6().scale(170);
      },
      'Eisenlohr': function() {
        return d3.geo.eisenlohr().scale(60);
      },
      'Equirectangular (Plate Carrée)': function() {
        return d3.geo.equirectangular();
      },
      'Goode Homolosine': function() {
        return d3.geo.homolosine();
      },
      'Hammer': function() {
        return d3.geo.hammer().scale(165);
      },
      'Hill': function() {
        return d3.geo.hill();
      },
      'Kavrayskiy VII': function() {
        return d3.geo.kavrayskiy7();
      },
      'Lagrange': function() {
        return d3.geo.lagrange().scale(120);
      },
      'Lambert cylindrical equal-area': function() {
        return d3.geo.cylindricalEqualArea();
      },
      'Larrivée': function() {
        return d3.geo.larrivee().scale(95);
      },
      'Laskowski': function() {
        return d3.geo.laskowski().scale(120);
      },
      'Loximuthal': function() {
        return d3.geo.loximuthal();
      },
      'McBryde–Thomas Flat-Polar Parabolic': function() {
        return d3.geo.mtFlatPolarParabolic();
      },
      'McBryde–Thomas Flat-Polar Quartic': function() {
        return d3.geo.mtFlatPolarQuartic();
      },
      'McBryde–Thomas Flat-Polar Sinusoidal': function() {
        return d3.geo.mtFlatPolarSinusoidal();
      },
      'Miller': function() {
        return d3.geo.miller().scale(100);
      },
      'Mollweide': function() {
        return d3.geo.mollweide().scale(165);
      },
      'Natural Earth': function() {
        return d3.geo.naturalEarth();
      },
      'Nell–Hammer': function() {
        return d3.geo.nellHammer();
      },
      'Polyconic': function() {
        return d3.geo.polyconic().scale(100);
      },
      'Robinson': function() {
        return d3.geo.robinson();
      },
      'Sinu-Mollweide': function() {
        return d3.geo.sinuMollweide();
      },
      'Sinusoidal': function() {
        return d3.geo.sinusoidal();
      },
      'Wagner IV': function() {
        return d3.geo.wagner4();
      },
      'Wagner VI': function() {
        return d3.geo.wagner6();
      },
      'Wagner VII': function() {
        return d3.geo.wagner7();
      },
      'Winkel Tripel': function() {
        return d3.geo.winkel3();
      },
      'van der Grinten': function() {
        return d3.geo.vanDerGrinten().scale(75);
      },
      'van der Grinten IV': function() {
        return d3.geo.vanDerGrinten4().scale(120);
      }
    },
    config_path_base: './data/config.yaml',
    config_path: [],
    config: null
  };

  (function() {
    var conf_merge, err, fs, k, p0, path, path_conf, path_home, scale_factor, yaml, _fn, _ref, _ref1, _results;
    scale_factor = Math.min(opts.w / 960, opts.h / 500);
    _ref = opts.projections;
    _fn = function(p0) {
      return opts.projections[k] = function() {
        var p, v;
        p = p0().rotate([0, 0, 0]).center([0, 0]);
        return p.scale(p.scale() * scale_factor).translate((function() {
          var _i, _len, _ref1, _results;
          _ref1 = p.translate();
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            v = _ref1[_i];
            _results.push(v * scale_factor);
          }
          return _results;
        })());
      };
    };
    for (k in _ref) {
      p0 = _ref[k];
      _fn(p0);
    }
    _ref1 = ['path', 'fs', 'js-yaml'].map(require), path = _ref1[0], fs = _ref1[1], yaml = _ref1[2];
    path_home = process.env[(process.platform === 'win32' ? 'USERPROFILE' : 'HOME')];
    conf_merge = function(conf, ext) {
      var v;
      for (k in ext) {
        if (!__hasProp.call(ext, k)) continue;
        v = ext[k];
        if (k in conf) {
          if (Array.isArray(conf[k]) && Array.isArray(v)) {
            v = d3.merge([conf[k], v]);
          } else if (typeof conf[k] === 'object' && typeof v === 'object') {
            v = conf_merge(conf[k], v);
          }
        }
        conf[k] = v;
      }
      return conf;
    };
    path_conf = opts.config_path_base;
    _results = [];
    while (path_conf) {
      if (path_conf.match(/^~\//)) {
        assert(path_home, 'Unable to get user home path from env');
        path_conf = path.join(path_home, path_conf.substr(2));
      }
      path_conf = path.resolve(path_conf);
      try {
        path_conf = fs.realpathSync(path_conf);
      } catch (_error) {
        break;
      }
      if (__indexOf.call(opts.config_path, path_conf) >= 0) {
        break;
      }
      opts.config_path.push(path_conf);
      try {
        opts.config = yaml.safeLoad(fs.readFileSync(path_conf, {
          encoding: 'utf-8'
        }), {
          filename: path_conf,
          strict: true,
          schema: yaml.CORE_SCHEMA
        });
      } catch (_error) {
        err = _error;
        util.error("Failed to process configuration file: " + path_conf + "\n  " + err);
        process.exit(1);
      }
      if (process.env['PSC_CONF']) {
        opts.config.extension = process.env['PSC_CONF'];
        process.env['PSC_CONF'] = null;
      }
      path_conf = opts.config.extension || null;
      _results.push(delete opts.config.extension);
    }
    return _results;
  })();

  proj = {
    name: opts.config.projection.name,
    func: null,
    path: null,
    list: (function() {
      var _ref, _results;
      _ref = opts.projections;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(k);
      }
      return _results;
    })(),
    graticule: d3.geo.graticule(),
    traces: null,
    markers: null
  };

  proj.func = opts.projections[proj.name]().translate([opts.w / 2, opts.h / 2]);

  proj.path = d3.geo.path().projection(proj.func);

  svg = d3.select('svg').attr('width', opts.w).attr('height', opts.h).attr('class', 'centered').style({
    'margin-left': '-' + (opts.w / 2) + 'px',
    'margin-top': '-' + (opts.h / 2) + 'px'
  });

  svg.append('defs').append('path').datum({
    type: 'Sphere'
  }).attr('id', 'sphere').attr('d', proj.path);

  svg.append('use').attr('class', 'stroke').attr('xlink:href', '#sphere');

  svg.append('use').attr('class', 'fill').attr('xlink:href', '#sphere');

  svg.append('path').datum(proj.graticule).attr('class', 'graticule').attr('d', proj.path);

  svg.insert('path', '.graticule').datum(topojson.feature(opts.world, opts.world.objects.land)).attr('class', 'land').attr('d', proj.path);

  proj.traces = svg.append('g').attr('id', 'traces');

  proj.markers = svg.append('g').attr('id', 'markers');

  (function() {
    var menu_opts, projectionTween, update;
    projectionTween = function(projection0, projection1) {
      return function(d) {
        var project, t;
        project = function(λ, φ) {
          var p0, p1, _ref;
          λ *= 180 / Math.PI;
          φ *= 180 / Math.PI;
          _ref = [projection0([λ, φ]), projection1([λ, φ])], p0 = _ref[0], p1 = _ref[1];
          return [(1 - t) * p0[0] + t * p1[0], (1 - t) * -p0[1] + t * -p1[1]];
        };
        t = 0;
        proj.func = d3.geo.projection(project).scale(1).translate([opts.w / 2, opts.h / 2]);
        proj.path = d3.geo.path().projection(proj.func);
        return function(_) {
          t = _;
          return proj.path(d);
        };
      };
    };
    update = function() {
      var projection0, _ref;
      k = proj.list[this.selectedIndex];
      _ref = [proj.func, opts.projections[k]()], projection0 = _ref[0], proj.func = _ref[1];
      proj.name = k;
      return svg.selectAll('path').transition().duration(750).attrTween('d', projectionTween(projection0, proj.func));
    };
    menu_opts = d3.select('#projection-menu').style('display', 'block').on('change', update).selectAll('option').data((function() {
      var _ref, _results;
      _ref = opts.projections;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push({
          name: k,
          projection: v()
        });
      }
      return _results;
    })());
    menu_opts.enter().append('option').text(function(d) {
      return d.name;
    });
    return menu_opts.attr('selected', function(d) {
      if (d.name === proj.name) {
        return true;
      } else {
        return null;
      }
    });
  })();

  Cache = (function(_super) {
    __extends(Cache, _super);

    function Cache(data, lwm, hwm_k) {
      var ts, _ref;
      this.lwm = lwm != null ? lwm : 300;
      if (hwm_k == null) {
        hwm_k = 1.5;
      }
      Cache.__super__.constructor.call(this);
      _ref = [d3.map(), this.lwm * hwm_k], this.data = _ref[0], this.hwm = _ref[1];
      if (data) {
        ts = (new Date()).getTime();
        for (k in data) {
          if (!__hasProp.call(data, k)) continue;
          v = data[k];
          this.set(k, v, ts);
        }
      }
      this.on('set', this.clean);
    }

    Cache.prototype.has = function(k) {
      return this.data.has(k);
    };

    Cache.prototype.get = function(k, ts) {
      v = this.data.get(k);
      if (v == null) {
        return v;
      }
      if (ts == null) {
        ts = (new Date()).getTime();
      }
      v.ts = ts;
      this.emit('get', k, v.v, ts);
      return v.v;
    };

    Cache.prototype.set = function(k, v, ts) {
      if (ts == null) {
        ts = (new Date()).getTime();
      }
      this.data.set({
        ts: ts,
        v: v
      });
      return this.emit('set', k, v, ts);
    };

    Cache.prototype.clean = function() {
      var e, _i, _len, _ref, _results;
      if (this.data.size() <= this.hwm) {
        return;
      }
      _ref = this.data.entries().sort(function(a, b) {
        return a.ts - b.ts;
      }).slice(0, +this.lwm + 1 || 9e9);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        _results.push(this.data.remove(e.key));
      }
      return _results;
    };

    return Cache;

  })(events.EventEmitter);

  Tracer = (function(_super) {
    __extends(Tracer, _super);

    Tracer.prototype.mtr_cycles = 1;

    Tracer.prototype.geotrace = function(ip) {
      var hop_label_format, hops, label_buff, last_hop, link_length, mtr, self, _ref, _ref1;
      mtr = new Mtr(ip, {
        reportCycles: this.mtr_cycles
      });
      _ref = [this, []], self = _ref[0], hops = _ref[1];
      _ref1 = [0, null, []], link_length = _ref1[0], last_hop = _ref1[1], label_buff = _ref1[2];
      hop_label_format = function(hop) {
        var label;
        label = hop.ip;
        if (label_buff.length) {
          label_buff.push(label);
          label = label_buff.join(' -> ');
          label_buff = [];
        }
        return label;
      };
      return mtr.on('hop', function(hop) {
        var geo, label, loc, _ref2;
        link_length += 1;
        last_hop = hop;
        if (hop.number === 1 || !hop.ip) {
          return;
        }
        geo = geoip.lookup(hop.ip);
        if (!geo) {
          label_buff.push(hop.ip);
          return;
        }
        label = hop_label_format(hop);
        loc = geo.city ? "" + geo.city + ", " + geo.country : "" + geo.country;
        hops.push({
          label: "" + label + " (" + loc + ")",
          geo: geo.ll,
          link: link_length
        });
        return _ref2 = [0, null], link_length = _ref2[0], last_hop = _ref2[1], _ref2;
      }).on('end', function() {
        var label;
        if (last_hop) {
          label = hop_label_format(last_hop);
          hops.push({
            label: "" + label,
            geo: null,
            link: link_length
          });
        }
        return self.emit('trace', ip, hops);
      }).on('error', function(err) {
        return console.log('traceroute error (ip: #{ip}): #{err.message}');
      }).traceroute();
    };

    Tracer.prototype.conn_add = function(ip) {
      return this.emit('conn_add', ip);
    };

    Tracer.prototype.conn_del = function(ip) {
      return this.emit('conn_del', ip);
    };

    Tracer.prototype.conn_list = function(ip_list) {
      return this.emit('conn_list', ip_list);
    };

    function Tracer() {
      Tracer.__super__.constructor.call(this);
      this.conn = {
        active: {},
        pending: {},
        cache: new Cache()
      };
      this.on('trace', function(ip, hops) {
        if (!this.conn.pending[ip]) {
          return;
        }
        this.conn.active[ip] = hops;
        this.conn.cache.set(ip, hops);
        return delete this.conn.pending[ip];
      }).on('conn_add', function(ip) {
        var hops;
        if (this.conn.active[ip] || this.conn.pending[ip]) {
          return;
        }
        hops = this.conn.cache.get(ip);
        if (hops) {
          return this.emit('trace', ip, hops);
        } else {
          this.conn.pending[ip] = true;
          return this.geotrace(ip);
        }
      }).on('conn_del', function(ip) {
        if (!this.conn.active[ip]) {
          return;
        }
        delete this.conn.active[ip];
        return delete this.conn.pending[ip];
      }).on('conn_list', function(ip_list) {
        var active, hops, ip, _i, _len, _ref, _results;
        active = {};
        _ref = this.conn.active;
        for (ip in _ref) {
          if (!__hasProp.call(_ref, ip)) continue;
          hops = _ref[ip];
          active[k] = v;
        }
        for (_i = 0, _len = ip_list.length; _i < _len; _i++) {
          ip = ip_list[_i];
          if (active[ip]) {
            delete active[ip];
            continue;
          }
          this.conn_add(ip);
        }
        _results = [];
        for (ip in active) {
          if (!__hasProp.call(active, ip)) continue;
          hops = active[ip];
          _results.push(this.conn_del(ip));
        }
        return _results;
      });
    }

    Tracer.in_domain = function(d) {
      if (!d) {
        d = domain.create();
      }
      return d.run(function() {
        return new Tracer();
      });
    };

    return Tracer;

  })(events.EventEmitter);

  ConntrackSS = (function(_super) {
    __extends(ConntrackSS, _super);

    function ConntrackSS() {
      return ConntrackSS.__super__.constructor.apply(this, arguments);
    }

    ConntrackSS.prototype.polling = true;

    ConntrackSS.prototype.poll = function() {
      var self, ss, ss_buff, ss_err, ss_header, ss_out, _ref;
      self = this;
      ss = child_process.spawn('ss', ['-np', '-A', 'inet', 'state', 'established'], {
        stdio: ['ignore', 'pipe', process.stderr]
      });
      _ref = ['', '', true, []], ss_out = _ref[0], ss_err = _ref[1], ss_header = _ref[2], ss_buff = _ref[3];
      ss.stdout.on('end', function() {
        return self.emit('conn_list', ss_buff);
      }).on('data', function(d) {
        var conn, e, ip, line, lines, m, p, port, props, proto, q_recv, q_send, re, s, s_local, s_remote, _i, _len, _ref1, _ref2, _ref3, _ref4, _results;
        ss_out += d;
        lines = ss_out.split('\n');
        if (lines.length < 2) {
          return;
        }
        _ref1 = [lines[lines.length - 1], lines.slice(0, -1)], ss_out = _ref1[0], lines = _ref1[1];
        if (ss_header) {
          lines = lines.slice(1);
        }
        _results = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          line = line.split(/\s+/);
          assert((_ref2 = line.length) === 5 || _ref2 === 6);
          if (line.length === 6) {
            _ref3 = [line[line.length - 1], line.slice(0, -1)], props = _ref3[0], line = _ref3[1];
          }
          proto = line[0], q_recv = line[1], q_send = line[2], s_local = line[3], s_remote = line[4];
          _ref4 = (function() {
            var _j, _len1, _ref4, _ref5, _results1;
            _ref4 = [s_local, s_remote];
            _results1 = [];
            for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
              s = _ref4[_j];
              _ref5 = s.match(/^(.+):(\d+)$/).slice(1, 3), ip = _ref5[0], port = _ref5[1];
              _results1.push([ip.replace(/^::ffff:/, ''), port]);
            }
            return _results1;
          })(), s_local = _ref4[0], s_remote = _ref4[1];
          if (props) {
            try {
              props = {
                users: ((function() {
                  var _results1;
                  p = props.match(/^users:\((.*)\)$/);
                  assert(p, "Can't match 'users:...' from: " + props);
                  re = /\("((?:[^\\"]|\\.)*)",(\d+),(\d+)\)(?:,|$)/g;
                  _results1 = [];
                  while (m = re.exec(p[1])) {
                    _results1.push({
                      cmd: m[1],
                      pid: parseInt(m[2]),
                      fd: parseInt(m[3])
                    });
                  }
                  return _results1;
                })())
              };
            } catch (_error) {
              e = _error;
              throw_err("Failed to parse prop-string `" + props + "': " + e);
            }
          }
          conn = {
            proto: proto,
            queues: {
              recv: parseInt(q_recv),
              send: parseInt(q_send)
            },
            local: {
              addr: s_local[0],
              port: parseInt(s_local[1])
            },
            remote: {
              addr: s_remote[0],
              port: parseInt(s_remote[1])
            },
            props: props
          };
          _results.push(ss_buff.push(conn));
        }
        return _results;
      }).setEncoding('utf8');
      return ss.on('exit', function(code, sig) {
        if ((code == null) || code !== 0 || sig) {
          return throw_err("ss - exit with error: " + code + ", " + sig);
        }
      }).on('error', function(err) {
        return throw_err("ss - failed to run: " + err);
      });
    };

    ConntrackSS.prototype.start = function(poll_interval) {
      assert(!this.timer, this.timer);
      return this.timer = (function(s) {
        return setInterval((function() {
          return s.poll();
        }), poll_interval * 1000);
      })(this);
    };

    ConntrackSS.prototype.stop = function() {
      return this.timer = this.timer && clearInterval(this.timer) && null;
    };

    ConntrackSS.in_domain = function(d) {
      if (!d) {
        d = domain.create();
      }
      return d.run(function() {
        return new ConntrackSS();
      });
    };

    return ConntrackSS;

  })(events.EventEmitter);

  (function() {
    var ct, draw_traces, source, trace_path, tracer;
    tracer = Tracer.in_domain();
    ct = ConntrackSS.in_domain();
    if (ct.polling) {
      ct.on('conn_list', function(conn_list) {
        var conn;
        return tracer.conn_list((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = conn_list.length; _i < _len; _i++) {
            conn = conn_list[_i];
            _results.push(conn.remote.addr);
          }
          return _results;
        })());
      });
    } else {
      ct.on('conn_add', function(conn) {
        return tracer.conn_add(conn.remote.addr);
      }).on('conn_del', function(conn) {
        return tracer.conn_del(conn.remote.addr);
      });
    }
    trace_path = d3.geo.path().projection(proj.func);
    source = opts.config.projection.source;
    draw_traces = function(traces) {
      var data, ip, marker_traces, markers, trace;
      data = (function() {
        var _results;
        _results = [];
        for (ip in traces) {
          if (!__hasProp.call(traces, ip)) continue;
          trace = traces[ip];
          if (trace.filter(function(d) {
            return d.geo;
          }).length !== 0) {
            _results.push({
              ip: ip,
              trace: trace
            });
          }
        }
        return _results;
      })();
      traces = proj.traces.selectAll('path.trace').data(data, function(d) {
        return d.ip;
      });
      traces.enter().append('path').datum(function(d) {
        return {
          type: 'MultiLineString',
          coordinates: (function() {
            var line, node, p0, p1, _i, _len, _ref, _ref1, _results;
            p0 = source.slice(0).reverse();
            _ref = d.trace;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              assert(node.geo, [node, d.trace]);
              p1 = node.geo.slice(0).reverse();
              _ref1 = [p1, [p0, p1]], p0 = _ref1[0], line = _ref1[1];
              _results.push(line);
            }
            return _results;
          })()
        };
      }).attr('class', 'trace').attr('d', trace_path);
      traces.exit().remove();
      marker_traces = proj.markers.selectAll('g').data(data, function(d) {
        return d.ip;
      });
      marker_traces.enter().append('g');
      marker_traces.exit().remove();
      markers = marker_traces.selectAll('circle').data(function(d) {
        return d.trace;
      });
      markers.enter().append('circle').datum(function(d) {
        return proj.func(d.geo.slice(0).reverse());
      }).attr('class', 'point').attr('cx', function(d) {
        return d[0];
      }).attr('cy', function(d) {
        return d[1];
      }).attr('r', 2);
      return markers.exit().remove();
    };
    ct.start(opts.config.updates.conntrack_poll);
    return setInterval((function() {
      return draw_traces(tracer.conn.active);
    }), opts.config.updates.redraw * 1000);
  })();

}).call(this);
