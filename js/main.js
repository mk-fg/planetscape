// Generated by CoffeeScript 1.7.1
(function() {
  var Cache, EventEmitter, Mtr, Tracer, geoip, graticule, k, menu_opts, opts, p0, path, projection, projectionTween, projection_name, projections_idx, scale_factor, svg, update, v, _fn, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  Mtr = require('mtr').Mtr;

  geoip = require('geoip-lite');

  opts = {
    w: window.innerWidth * 0.9,
    h: window.innerHeight * 0.9,
    world: require('./data/world-110m.json'),
    projections: {
      'Aitoff': function() {
        return d3.geo.aitoff();
      },
      'Albers': function() {
        return d3.geo.albers().scale(145).parallels([20, 50]);
      },
      'August': function() {
        return d3.geo.august().scale(60);
      },
      'Baker': function() {
        return d3.geo.baker().scale(100);
      },
      'Boggs': function() {
        return d3.geo.boggs();
      },
      'Bonne': function() {
        return d3.geo.bonne().scale(100);
      },
      'Bromley': function() {
        return d3.geo.bromley();
      },
      'Collignon': function() {
        return d3.geo.collignon().scale(93);
      },
      'Craster Parabolic': function() {
        return d3.geo.craster();
      },
      'Eckert I': function() {
        return d3.geo.eckert1().scale(165);
      },
      'Eckert II': function() {
        return d3.geo.eckert2().scale(165);
      },
      'Eckert III': function() {
        return d3.geo.eckert3().scale(180);
      },
      'Eckert IV': function() {
        return d3.geo.eckert4().scale(180);
      },
      'Eckert V': function() {
        return d3.geo.eckert5().scale(170);
      },
      'Eckert VI': function() {
        return d3.geo.eckert6().scale(170);
      },
      'Eisenlohr': function() {
        return d3.geo.eisenlohr().scale(60);
      },
      'Equirectangular (Plate Carrée)': function() {
        return d3.geo.equirectangular();
      },
      'Goode Homolosine': function() {
        return d3.geo.homolosine();
      },
      'Hammer': function() {
        return d3.geo.hammer().scale(165);
      },
      'Hill': function() {
        return d3.geo.hill();
      },
      'Kavrayskiy VII': function() {
        return d3.geo.kavrayskiy7();
      },
      'Lagrange': function() {
        return d3.geo.lagrange().scale(120);
      },
      'Lambert cylindrical equal-area': function() {
        return d3.geo.cylindricalEqualArea();
      },
      'Larrivée': function() {
        return d3.geo.larrivee().scale(95);
      },
      'Laskowski': function() {
        return d3.geo.laskowski().scale(120);
      },
      'Loximuthal': function() {
        return d3.geo.loximuthal();
      },
      'McBryde–Thomas Flat-Polar Parabolic': function() {
        return d3.geo.mtFlatPolarParabolic();
      },
      'McBryde–Thomas Flat-Polar Quartic': function() {
        return d3.geo.mtFlatPolarQuartic();
      },
      'McBryde–Thomas Flat-Polar Sinusoidal': function() {
        return d3.geo.mtFlatPolarSinusoidal();
      },
      'Miller': function() {
        return d3.geo.miller().scale(100);
      },
      'Mollweide': function() {
        return d3.geo.mollweide().scale(165);
      },
      'Natural Earth': function() {
        return d3.geo.naturalEarth();
      },
      'Nell–Hammer': function() {
        return d3.geo.nellHammer();
      },
      'Polyconic': function() {
        return d3.geo.polyconic().scale(100);
      },
      'Robinson': function() {
        return d3.geo.robinson();
      },
      'Sinu-Mollweide': function() {
        return d3.geo.sinuMollweide();
      },
      'Sinusoidal': function() {
        return d3.geo.sinusoidal();
      },
      'Wagner IV': function() {
        return d3.geo.wagner4();
      },
      'Wagner VI': function() {
        return d3.geo.wagner6();
      },
      'Wagner VII': function() {
        return d3.geo.wagner7();
      },
      'Winkel Tripel': function() {
        return d3.geo.winkel3();
      },
      'van der Grinten': function() {
        return d3.geo.vanDerGrinten().scale(75);
      },
      'van der Grinten IV': function() {
        return d3.geo.vanDerGrinten4().scale(120);
      }
    },
    defaults: {
      source: [56.833333, 60.583333],
      projection: 'Equirectangular (Plate Carrée)'
    }
  };

  scale_factor = Math.min(opts.w / 960, opts.h / 500);

  _ref = opts.projections;
  _fn = function(p0) {
    return opts.projections[k] = function() {
      var p, v;
      p = p0().rotate([0, 0, 0]).center([0, 0]);
      return p.scale(p.scale() * scale_factor).translate((function() {
        var _i, _len, _ref1, _results;
        _ref1 = p.translate();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          v = _ref1[_i];
          _results.push(v * scale_factor);
        }
        return _results;
      })());
    };
  };
  for (k in _ref) {
    p0 = _ref[k];
    _fn(p0);
  }

  projections_idx = (function() {
    var _ref1, _results;
    _ref1 = opts.projections;
    _results = [];
    for (k in _ref1) {
      v = _ref1[k];
      _results.push(k);
    }
    return _results;
  })();

  projection_name = opts.defaults.projection;

  projection = opts.projections[projection_name]().translate([opts.w / 2, opts.h / 2]);

  path = d3.geo.path().projection(projection);

  graticule = d3.geo.graticule();

  svg = d3.select('svg').attr('width', opts.w).attr('height', opts.h).attr('class', 'centered').style({
    'margin-left': '-' + (opts.w / 2) + 'px',
    'margin-top': '-' + (opts.h / 2) + 'px'
  });

  svg.append('defs').append('path').datum({
    type: 'Sphere'
  }).attr('id', 'sphere').attr('d', path);

  svg.append('use').attr('class', 'stroke').attr('xlink:href', '#sphere');

  svg.append('use').attr('class', 'fill').attr('xlink:href', '#sphere');

  svg.append('path').datum(graticule).attr('class', 'graticule').attr('d', path);

  svg.insert('path', '.graticule').datum(topojson.feature(opts.world, opts.world.objects.land)).attr('class', 'land').attr('d', path);

  Cache = (function(_super) {
    __extends(Cache, _super);

    function Cache(data, lwm, hwm_k) {
      var ts, _ref1;
      this.lwm = lwm != null ? lwm : 300;
      if (hwm_k == null) {
        hwm_k = 1.5;
      }
      Cache.__super__.constructor.call(this);
      _ref1 = [d3.map(), this.lwm * hwm_k], this.data = _ref1[0], this.hwm = _ref1[1];
      if (data) {
        ts = (new Date()).getTime();
        for (k in data) {
          if (!__hasProp.call(data, k)) continue;
          v = data[k];
          this.set(k, v, ts);
        }
      }
      this.on('set', this.clean);
    }

    Cache.prototype.has = function(k) {
      return this.data.has(k);
    };

    Cache.prototype.get = function(k, ts) {
      v = this.data.get(k);
      if (v == null) {
        return v;
      }
      if (ts == null) {
        ts = (new Date()).getTime();
      }
      v.ts = ts;
      this.emit('get', k, v.v, ts);
      return v.v;
    };

    Cache.prototype.set = function(k, v, ts) {
      if (ts == null) {
        ts = (new Date()).getTime();
      }
      this.data.set({
        ts: ts,
        v: v
      });
      return this.emit('set', k, v, ts);
    };

    Cache.prototype.clean = function() {
      var e, _i, _len, _ref1, _results;
      if (this.data.size() <= this.hwm) {
        return;
      }
      _ref1 = this.data.entries().sort(function(a, b) {
        return a.ts - b.ts;
      }).slice(0, +this.lwm + 1 || 9e9);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        e = _ref1[_i];
        _results.push(this.data.remove(e.key));
      }
      return _results;
    };

    return Cache;

  })(EventEmitter);

  Tracer = (function(_super) {
    __extends(Tracer, _super);

    Tracer.prototype.mtr_cycles = 1;

    Tracer.prototype.geotrace = function(ip) {
      var hop_label_format, hops, label_buff, last_hop, link_length, mtr, self, _ref1, _ref2;
      mtr = new Mtr(ip, {
        reportCycles: this.mtr_cycles
      });
      _ref1 = [this, []], self = _ref1[0], hops = _ref1[1];
      _ref2 = [0, null, []], link_length = _ref2[0], last_hop = _ref2[1], label_buff = _ref2[2];
      hop_label_format = function(hop) {
        var label;
        label = hop.ip;
        if (label_buff.length) {
          label_buff.push(label);
          label = label_buff.join(' -> ');
          label_buff = [];
        }
        return label;
      };
      mtr.on('hop', function(hop) {
        var geo, label, loc, _ref3;
        link_length += 1;
        last_hop = hop;
        if (hop.number === 1 || !hop.ip) {
          return;
        }
        geo = geoip.lookup(hop.ip);
        if (!geo) {
          label_buff.push(label_addr);
          return;
        }
        label = hop_label_format(hop);
        loc = geo.city ? "" + geo.city + ", " + geo.country : "" + geo.country;
        hops.push({
          label: "" + label + " (" + loc + ")",
          geo: geo.ll,
          link: link_length
        });
        return _ref3 = [0, null], link_length = _ref3[0], last_hop = _ref3[1], _ref3;
      });
      mtr.on('end', function() {
        var label;
        if (last_hop) {
          label = hop_label_format(last_hop);
          hops.push({
            label: "" + label,
            geo: null,
            link: link_length
          });
        }
        return self.emit('trace', ip, hops);
      });
      mtr.on('error', function(err) {
        return console.log('traceroute error (ip: #{ip}): #{err.message}');
      });
      return mtr.traceroute();
    };

    Tracer.prototype.conn_add = function(ip) {
      return this.emit('conn_add', ip);
    };

    Tracer.prototype.conn_del = function(ip) {
      return this.emit('conn_del', ip);
    };

    Tracer.prototype.conn_list = function(ip_list) {
      return this.emit('conn_list', ip_list);
    };

    function Tracer() {
      Tracer.__super__.constructor.call(this);
      this.conn = {
        active: {},
        pending: {},
        cache: new Cache()
      };
      this.on('trace', function(ip, hops) {
        if (!this.conn.pending[ip]) {
          return;
        }
        this.conn.active[ip] = hops;
        this.conn.cache.set(ip, hops);
        return delete this.conn.pending[ip];
      });
      this.on('conn_add', function(ip) {
        var hops;
        if (this.conn.active[ip]) {
          return;
        }
        hops = this.conn.cache.get(ip);
        if (hops) {
          return this.emit('trace', ip, hops);
        } else {
          this.conn.pending[ip] = true;
          return this.geotrace(ip);
        }
      });
      this.on('conn_del', function(ip) {
        if (!this.conn.active[ip]) {
          return;
        }
        delete this.conn.active[ip];
        return delete this.conn.pending[ip];
      });
      this.on('conn_list', function(ip_list) {
        var active, ip, _i, _j, _len, _len1, _results;
        active = this.conn.active.slice(0);
        for (_i = 0, _len = ip_list.length; _i < _len; _i++) {
          ip = ip_list[_i];
          if (active[ip]) {
            delete active.indexOf(ip);
            continue;
          }
          this.conn_add('conn_add', ip);
        }
        _results = [];
        for (_j = 0, _len1 = active.length; _j < _len1; _j++) {
          ip = active[_j];
          _results.push(this.conn_del(ip));
        }
        return _results;
      });
    }

    return Tracer;

  })(EventEmitter);

  projectionTween = function(projection0, projection1) {
    return function(d) {
      var project, t;
      project = function(λ, φ) {
        var p1, _ref1;
        λ *= 180 / Math.PI;
        φ *= 180 / Math.PI;
        _ref1 = [projection0([λ, φ]), projection1([λ, φ])], p0 = _ref1[0], p1 = _ref1[1];
        return [(1 - t) * p0[0] + t * p1[0], (1 - t) * -p0[1] + t * -p1[1]];
      };
      t = 0;
      projection = d3.geo.projection(project).scale(1).translate([opts.w / 2, opts.h / 2]);
      path = d3.geo.path().projection(projection);
      return function(_) {
        t = _;
        return path(d);
      };
    };
  };

  update = function() {
    var projection0, _ref1;
    k = projections_idx[this.selectedIndex];
    _ref1 = [projection, opts.projections[k]()], projection0 = _ref1[0], projection = _ref1[1];
    projection_name = k;
    return svg.selectAll('path').transition().duration(750).attrTween('d', projectionTween(projection0, projection));
  };

  menu_opts = d3.select('#projection-menu').style('display', 'block').on('change', update).selectAll('option').data((function() {
    var _ref1, _results;
    _ref1 = opts.projections;
    _results = [];
    for (k in _ref1) {
      v = _ref1[k];
      _results.push({
        name: k,
        projection: v()
      });
    }
    return _results;
  })());

  menu_opts.enter().append('option').text(function(d) {
    return d.name;
  });

  menu_opts.attr('selected', function(d) {
    if (d.name === projection_name) {
      return true;
    } else {
      return null;
    }
  });

}).call(this);
