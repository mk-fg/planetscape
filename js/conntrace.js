// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Cache, ConntrackSS, Tracer, child_process, domain, events, geoip, mtr, u,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  u = require('./utils');

  domain = require('domain');

  events = require('events');

  child_process = require('child_process');

  mtr = require('mtr');

  geoip = require('geoip-lite');

  Cache = (function(_super) {
    __extends(Cache, _super);

    function Cache(data, lwm, hwm_k) {
      var k, ts, v, _ref;
      this.lwm = lwm != null ? lwm : 300;
      if (hwm_k == null) {
        hwm_k = 1.5;
      }
      Cache.__super__.constructor.call(this);
      _ref = [{}, this.lwm * hwm_k], this.data = _ref[0], this.hwm = _ref[1];
      if (data) {
        ts = (new Date()).getTime();
        for (k in data) {
          if (!__hasProp.call(data, k)) continue;
          v = data[k];
          this.set(k, v, ts);
        }
      }
      this.on('set', this.clean);
    }

    Cache.prototype.has = function(k) {
      return typeof this.data[k] !== 'undefined';
    };

    Cache.prototype.get = function(k, ts) {
      var v;
      v = this.data[k];
      if (v == null) {
        return v;
      }
      if (ts == null) {
        ts = (new Date()).getTime();
      }
      v.ts = ts;
      this.emit('get', k, v.v, ts);
      return v.v;
    };

    Cache.prototype.set = function(k, v, ts) {
      if (ts == null) {
        ts = (new Date()).getTime();
      }
      this.data[k] = {
        ts: ts,
        v: v
      };
      return this.emit('set', k, v, ts);
    };

    Cache.prototype.clean = function() {
      var e, k, v, _i, _len, _ref, _results;
      if (Object.keys(this.data).length <= this.hwm) {
        return;
      }
      _ref = ((function() {
        var _ref, _results1;
        _ref = this.data;
        _results1 = [];
        for (k in _ref) {
          if (!__hasProp.call(_ref, k)) continue;
          v = _ref[k];
          _results1.push([k, v]);
        }
        return _results1;
      }).call(this)).sort(function(a, b) {
        return a[1].ts - b[1].ts;
      }).slice(0, +this.lwm + 1 || 9e9);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        _results.push(delete this.data[e[0]]);
      }
      return _results;
    };

    return Cache;

  })(events.EventEmitter);

  Tracer = (function(_super) {
    __extends(Tracer, _super);

    Tracer.prototype.mtr_cycles = 1;

    Tracer.prototype.geotrace = function(ip) {
      var hop_label_format, hops, label_buff, last_hop, link_length, self, trace, _ref, _ref1;
      trace = new mtr.Mtr(ip, {
        reportCycles: this.mtr_cycles
      });
      _ref = [this, []], self = _ref[0], hops = _ref[1];
      _ref1 = [0, null, []], link_length = _ref1[0], last_hop = _ref1[1], label_buff = _ref1[2];
      hop_label_format = function(hop) {
        var label;
        label = hop.ip;
        if (label_buff.length) {
          label_buff.push(label);
          label = label_buff.join(' -> ');
          label_buff = [];
        }
        return label;
      };
      return trace.on('hop', function(hop) {
        var geo, label, loc, _ref2;
        link_length += 1;
        last_hop = hop;
        if (hop.number === 1 || !hop.ip) {
          return;
        }
        geo = geoip.lookup(hop.ip);
        if (!geo) {
          label_buff.push(hop.ip);
          return;
        }
        label = hop_label_format(hop);
        loc = geo.city ? "" + geo.city + ", " + geo.country : "" + geo.country;
        hops.push({
          label: "" + label + " (" + loc + ")",
          geo: geo.ll,
          link: link_length
        });
        return _ref2 = [0, null], link_length = _ref2[0], last_hop = _ref2[1], _ref2;
      }).on('end', function() {
        var label;
        if (last_hop) {
          label = hop_label_format(last_hop);
          hops.push({
            label: "" + label,
            geo: null,
            link: link_length
          });
        }
        return self.emit('trace', ip, hops);
      }).on('error', function(err) {
        return console.log('traceroute error (ip: #{ip}): #{err.message}');
      }).traceroute();
    };

    Tracer.prototype.conn_add = function(ip) {
      return this.emit('conn_add', ip);
    };

    Tracer.prototype.conn_del = function(ip) {
      return this.emit('conn_del', ip);
    };

    Tracer.prototype.conn_list = function(ip_list) {
      return this.emit('conn_list', ip_list);
    };

    function Tracer() {
      Tracer.__super__.constructor.call(this);
      this.conn = {
        active: {},
        active_change_id: 0,
        pending: {},
        cache: new Cache()
      };
      this.on('conn_change', function() {
        return this.conn.active_change_id += 1;
      }).on('trace', function(ip, hops) {
        if (!this.conn.pending[ip]) {
          return;
        }
        this.conn.active[ip] = hops;
        this.conn.cache.set(ip, hops);
        delete this.conn.pending[ip];
        return this.emit('conn_change');
      }).on('conn_add', function(ip) {
        var hops;
        if (this.conn.active[ip] || this.conn.pending[ip]) {
          return;
        }
        hops = this.conn.cache.get(ip);
        if (hops) {
          return this.emit('trace', ip, hops);
        } else {
          this.conn.pending[ip] = true;
          return this.geotrace(ip);
        }
      }).on('conn_del', function(ip) {
        if (!this.conn.active[ip]) {
          return;
        }
        delete this.conn.active[ip];
        delete this.conn.pending[ip];
        return this.emit('conn_change');
      }).on('conn_list', function(ip_list) {
        var active, hops, ip, _i, _len, _ref, _results;
        active = {};
        _ref = this.conn.active;
        for (ip in _ref) {
          if (!__hasProp.call(_ref, ip)) continue;
          hops = _ref[ip];
          active[ip] = hops;
        }
        for (_i = 0, _len = ip_list.length; _i < _len; _i++) {
          ip = ip_list[_i];
          if (active[ip]) {
            delete active[ip];
            continue;
          }
          this.conn_add(ip);
        }
        _results = [];
        for (ip in active) {
          if (!__hasProp.call(active, ip)) continue;
          hops = active[ip];
          _results.push(this.conn_del(ip));
        }
        return _results;
      });
    }

    Tracer.in_domain = function(d) {
      if (!d) {
        d = domain.create();
      }
      return d.run(function() {
        return new Tracer();
      });
    };

    return Tracer;

  })(events.EventEmitter);

  ConntrackSS = (function(_super) {
    __extends(ConntrackSS, _super);

    function ConntrackSS() {
      return ConntrackSS.__super__.constructor.apply(this, arguments);
    }

    ConntrackSS.prototype.polling = true;

    ConntrackSS.prototype.poll = function() {
      var self, ss, ss_buff, ss_err, ss_header, ss_out, _ref;
      self = this;
      ss = child_process.spawn('ss', ['-np', '-A', 'inet', 'state', 'established'], {
        stdio: ['ignore', 'pipe', process.stderr]
      });
      _ref = ['', '', true, []], ss_out = _ref[0], ss_err = _ref[1], ss_header = _ref[2], ss_buff = _ref[3];
      ss.stdout.on('end', function() {
        return self.emit('conn_list', ss_buff);
      }).on('data', function(d) {
        var conn, e, ip, line, lines, m, p, port, props, proto, q_recv, q_send, re, s, s_local, s_remote, _i, _len, _ref1, _ref2, _ref3, _ref4, _results;
        ss_out += d;
        lines = ss_out.split('\n');
        if (lines.length < 2) {
          return;
        }
        _ref1 = [lines[lines.length - 1], lines.slice(0, -1)], ss_out = _ref1[0], lines = _ref1[1];
        if (ss_header) {
          lines = lines.slice(1);
        }
        _results = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          line = line.split(/\s+/);
          u.assert((_ref2 = line.length) === 5 || _ref2 === 6);
          if (line.length === 6) {
            _ref3 = [line[line.length - 1], line.slice(0, -1)], props = _ref3[0], line = _ref3[1];
          }
          proto = line[0], q_recv = line[1], q_send = line[2], s_local = line[3], s_remote = line[4];
          _ref4 = (function() {
            var _j, _len1, _ref4, _ref5, _results1;
            _ref4 = [s_local, s_remote];
            _results1 = [];
            for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
              s = _ref4[_j];
              _ref5 = s.match(/^(.+):(\d+)$/).slice(1, 3), ip = _ref5[0], port = _ref5[1];
              _results1.push([ip.replace(/^::ffff:/, ''), port]);
            }
            return _results1;
          })(), s_local = _ref4[0], s_remote = _ref4[1];
          if (props) {
            try {
              props = {
                users: ((function() {
                  var _results1;
                  p = props.match(/^users:\((.*)\)$/);
                  u.assert(p, "Can't match 'users:...' from: " + props);
                  re = /\("((?:[^\\"]|\\.)*)",(\d+),(\d+)\)(?:,|$)/g;
                  _results1 = [];
                  while (m = re.exec(p[1])) {
                    _results1.push({
                      cmd: m[1],
                      pid: parseInt(m[2]),
                      fd: parseInt(m[3])
                    });
                  }
                  return _results1;
                })())
              };
            } catch (_error) {
              e = _error;
              u.throw_err("Failed to parse prop-string `" + props + "': " + e);
            }
          }
          conn = {
            proto: proto,
            queues: {
              recv: parseInt(q_recv),
              send: parseInt(q_send)
            },
            local: {
              addr: s_local[0],
              port: parseInt(s_local[1])
            },
            remote: {
              addr: s_remote[0],
              port: parseInt(s_remote[1])
            },
            props: props
          };
          _results.push(ss_buff.push(conn));
        }
        return _results;
      }).setEncoding('utf8');
      return ss.on('exit', function(code, sig) {
        if ((code == null) || code !== 0 || sig) {
          return u.throw_err("ss - exit with error: " + code + ", " + sig);
        }
      }).on('error', function(err) {
        return u.throw_err("ss - failed to run: " + err);
      });
    };

    ConntrackSS.prototype.start = function(poll_interval, now) {
      if (now == null) {
        now = true;
      }
      u.assert(!this.timer, this.timer);
      return this.timer = (function(self) {
        var scheduler;
        scheduler = now ? u.add_task_now : u.add_task;
        return scheduler(poll_interval, function() {
          return self.poll();
        });
      })(this);
    };

    ConntrackSS.prototype.stop = function() {
      return this.timer = this.timer && clearInterval(this.timer) && null;
    };

    ConntrackSS.in_domain = function(d) {
      if (!d) {
        d = domain.create();
      }
      return d.run(function() {
        return new ConntrackSS();
      });
    };

    return ConntrackSS;

  })(events.EventEmitter);

  module.exports.Tracer = Tracer;

  module.exports.ConntrackSS = ConntrackSS;

}).call(this);
